
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/orientation_mapping/multi_phase_orientation.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_orientation_mapping_multi_phase_orientation.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_orientation_mapping_multi_phase_orientation.py:


Multi Phase Orientation Mapping
===============================
You can also calculate the orientation of the grains for multiple phases using the
:meth:`pyxem.signals.PolarSignal2D.get_orientation` method. This requires that you
simulate the entire S2 space for the phase and then compare to the simulated diffraction.

For more information on the orientation mapping process see :cite:`pyxemorientationmapping2022`

.. GENERATED FROM PYTHON SOURCE LINES 10-20

.. code-block:: Python


    import pyxem as pxm
    from pyxem.data import fe_multi_phase_grains, fe_bcc_phase, fe_fcc_phase
    from diffsims.generators.simulation_generator import SimulationGenerator
    from orix.quaternion import Rotation
    from orix.sampling import get_sample_reduced_fundamental
    import hyperspy.api as hs

    multi_phase = fe_multi_phase_grains()








.. GENERATED FROM PYTHON SOURCE LINES 21-26

First we center the diffraction patterns and get a polar signal
Increasing the number of npt_azim with give better polar sampling
but will take longer to compute the orientation map
The mean=True argument will return the mean pixel value in each bin rather than the sum
this makes the high k values more visible

.. GENERATED FROM PYTHON SOURCE LINES 26-33

.. code-block:: Python


    multi_phase.calibration.center = None
    polar_multi = multi_phase.get_azimuthal_integral2d(
        npt=100, npt_azim=360, inplace=False, mean=True
    )
    polar_multi.plot()




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /examples/orientation_mapping/images/sphx_glr_multi_phase_orientation_001.png
         :alt: multi phase orientation
         :srcset: /examples/orientation_mapping/images/sphx_glr_multi_phase_orientation_001.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples/orientation_mapping/images/sphx_glr_multi_phase_orientation_002.png
         :alt:  Signal
         :srcset: /examples/orientation_mapping/images/sphx_glr_multi_phase_orientation_002.png
         :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          | 0/26 [00:00<?, ?it/s]      4%|▍         | 1/26 [00:02<01:10,  2.83s/it]     19%|█▉        | 5/26 [00:02<00:09,  2.20it/s]     35%|███▍      | 9/26 [00:03<00:03,  4.45it/s]     50%|█████     | 13/26 [00:03<00:01,  7.07it/s]     65%|██████▌   | 17/26 [00:03<00:00,  9.97it/s]     77%|███████▋  | 20/26 [00:03<00:00, 11.30it/s]     88%|████████▊ | 23/26 [00:03<00:00, 13.45it/s]    100%|██████████| 26/26 [00:03<00:00,  6.97it/s]




.. GENERATED FROM PYTHON SOURCE LINES 34-37

Now we can get make a simulation. In this case we want to set a minimum_intensity which removes the
low intensity reflections. We also sample the S2 space using the :func:`orix.sampling.get_sample_reduced_fundamental`
We have two phases here so we can make a simulation object with both of the phases.

.. GENERATED FROM PYTHON SOURCE LINES 37-60

.. code-block:: Python


    bcc = fe_bcc_phase()
    fcc = fe_fcc_phase()
    bcc.name = "BCC Phase"
    fcc.name = "FCC Phase"
    fcc.color = "red"
    bcc.color = "blue"

    generator = SimulationGenerator(200, minimum_intensity=0.05)
    rotations_bcc = get_sample_reduced_fundamental(
        resolution=1, point_group=bcc.point_group
    )
    rotations_fcc = get_sample_reduced_fundamental(
        resolution=1, point_group=fcc.point_group
    )

    sim = generator.calculate_diffraction2d(
        [bcc, fcc],
        rotation=[rotations_bcc, rotations_fcc],
        max_excitation_error=0.1,
        reciprocal_radius=2,
        with_direct_beam=False,
    )







.. GENERATED FROM PYTHON SOURCE LINES 61-72

Orientation Mapping
-------------------
Now we can calculate the orientation map using the polar signal and the simulated diffraction pattern
Sometimes a gamma correction helps to re-normalize the intensity of the simulated diffraction pattern
and increase the intensity of the high k diffraction spots. Unfortunately this is quite dependent on the
detector response/ sample thickness etc. As a result there is no good rule of thumb.  As such it is important
to play with this value/ use the background correction to get the best results.
Additionally, here we have set the n_best to -1 which means that we will return all the
orientations in the simulation. This is not always the best option as it can lead to
memory spikes. It does allow us to plot a very nice heatmap of the orientation.
Which is useful for understanding the orientation mapping process and mis-orientations.

.. GENERATED FROM PYTHON SOURCE LINES 72-78

.. code-block:: Python



    polar_multi = polar_multi**0.5  # gamma correction
    orientation_map = polar_multi.get_orientation(sim, n_best=-1, frac_keep=1)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          | 0/26 [00:00<?, ?it/s]      4%|▍         | 1/26 [00:03<01:36,  3.87s/it]      8%|▊         | 2/26 [00:03<00:40,  1.67s/it]     19%|█▉        | 5/26 [00:04<00:13,  1.51it/s]     23%|██▎       | 6/26 [00:04<00:10,  1.89it/s]     35%|███▍      | 9/26 [00:05<00:06,  2.46it/s]     42%|████▏     | 11/26 [00:05<00:04,  3.46it/s]     50%|█████     | 13/26 [00:06<00:04,  2.95it/s]     62%|██████▏   | 16/26 [00:06<00:02,  4.62it/s]     69%|██████▉   | 18/26 [00:07<00:02,  3.57it/s]     81%|████████  | 21/26 [00:08<00:01,  3.45it/s]     92%|█████████▏| 24/26 [00:08<00:00,  4.95it/s]    100%|██████████| 26/26 [00:09<00:00,  5.17it/s]    100%|██████████| 26/26 [00:09<00:00,  2.83it/s]
      0%|          | 0/26 [00:00<?, ?it/s]    100%|██████████| 26/26 [00:00<00:00, 557.52it/s]




.. GENERATED FROM PYTHON SOURCE LINES 79-83

Plotting The Orientation Mapping
--------------------------------
We can then plot the orientation map using the :meth:`pyxem.signals.OrientationMap.plot_over_signal` method.
Here we have set add_ipf_correlation_heatmap=True which will add a heatmap of the IPF correlation.

.. GENERATED FROM PYTHON SOURCE LINES 83-88

.. code-block:: Python


    orientation_map.plot_over_signal(
        multi_phase, vmax="99th", add_ipf_correlation_heatmap=True
    )




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /examples/orientation_mapping/images/sphx_glr_multi_phase_orientation_003.png
         :alt: multi phase orientation
         :srcset: /examples/orientation_mapping/images/sphx_glr_multi_phase_orientation_003.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples/orientation_mapping/images/sphx_glr_multi_phase_orientation_004.png
         :alt:  Signal
         :srcset: /examples/orientation_mapping/images/sphx_glr_multi_phase_orientation_004.png
         :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          | 0/51 [00:00<?, ?it/s]    100%|██████████| 51/51 [00:00<00:00, 1545.67it/s]
      0%|          | 0/51 [00:00<?, ?it/s]    100%|██████████| 51/51 [00:00<00:00, 1710.44it/s]
      0%|          | 0/76 [00:00<?, ?it/s]     91%|█████████ | 69/76 [00:00<00:00, 639.94it/s]    100%|██████████| 76/76 [00:00<00:00, 670.55it/s]
      0%|          | 0/76 [00:00<?, ?it/s]     91%|█████████ | 69/76 [00:00<00:00, 643.89it/s]    100%|██████████| 76/76 [00:00<00:00, 662.61it/s]




.. GENERATED FROM PYTHON SOURCE LINES 89-96

Getting the Crystal Map
-----------------------
Now we can calculate the orientation map using the polar signal and the simulated diffraction pattern
Sometimes a gamma correction helps to re-normalize the intensity of the simulated diffraction pattern
and increase the intensity of the high k diffraction spots. Unfortunately this is quite dependent on the
detector response/ sample thickness etc. As a result there is no good rule of thumb.  As such it is important
to play with this value/ use the background correction to get the best results.

.. GENERATED FROM PYTHON SOURCE LINES 96-99

.. code-block:: Python


    cmap = orientation_map.to_crystal_map()
    cmap.plot()



.. image-sg:: /examples/orientation_mapping/images/sphx_glr_multi_phase_orientation_005.png
   :alt: multi phase orientation
   :srcset: /examples/orientation_mapping/images/sphx_glr_multi_phase_orientation_005.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          | 0/51 [00:00<?, ?it/s]     18%|█▊        | 9/51 [00:00<00:00, 75.87it/s]     49%|████▉     | 25/51 [00:00<00:00, 110.37it/s]     80%|████████  | 41/51 [00:00<00:00, 121.35it/s]    100%|██████████| 51/51 [00:00<00:00, 130.11it/s]
      0%|          | 0/51 [00:00<?, ?it/s]    100%|██████████| 51/51 [00:00<00:00, 1780.06it/s]




.. GENERATED FROM PYTHON SOURCE LINES 100-101

sphinx_gallery_thumbnail_number = 4


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 24.164 seconds)


.. _sphx_glr_download_examples_orientation_mapping_multi_phase_orientation.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: multi_phase_orientation.ipynb <multi_phase_orientation.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: multi_phase_orientation.py <multi_phase_orientation.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: multi_phase_orientation.zip <multi_phase_orientation.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
