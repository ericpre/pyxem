
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/vectors/clustering_vectors.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_vectors_clustering_vectors.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_vectors_clustering_vectors.py:


==================
Clustering Vectors
==================

This can be used to segment a 4-D STEM dataset into different clusters based on the diffraction
pattern at each real space position.

.. GENERATED FROM PYTHON SOURCE LINES 9-27

.. code-block:: Python


    import pyxem as pxm
    from scipy.ndimage import gaussian_filter
    import matplotlib.pyplot as plt
    from sklearn.cluster import DBSCAN

    # Getting the vectors for some dataset
    # s = pxm.data.mgo_nanocrystals(allow_download=True)
    s = pxm.data.simulated_overlap()
    s.filter(gaussian_filter, sigma=(0.5, 0.5, 0, 0), inplace=True)  # only in real space
    s.template_match_disk(disk_r=5, subtract_min=False, inplace=True)
    vectors = s.get_diffraction_vectors(threshold_abs=0.5, min_distance=3)

    # Now we can convert the vectors into a 2D array of rows/columns
    flat_vectors = (
        vectors.flatten_diffraction_vectors()
    )  # flatten the vectors into a 2D array
    scan = DBSCAN(eps=1.0, min_samples=2)




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/diffsims/generators/sphere_mesh_generators.py:523: RuntimeWarning: invalid value encountered in divide
      phi2 = sign * np.nan_to_num(np.arccos(x_comp / norm_proj))
      0%|          | 0/9 [00:00<?, ?it/s]     11%|█         | 1/9 [00:08<01:07,  8.44s/it]     44%|████▍     | 4/9 [00:08<00:08,  1.65s/it]     56%|█████▌    | 5/9 [00:16<00:13,  3.47s/it]     67%|██████▋   | 6/9 [00:16<00:07,  2.52s/it]    100%|██████████| 9/9 [00:16<00:00,  1.89s/it]
      0%|          | 0/17 [00:00<?, ?it/s]      6%|▌         | 1/17 [00:06<01:38,  6.16s/it]     18%|█▊        | 3/17 [00:07<00:27,  1.99s/it]     41%|████      | 7/17 [00:07<00:07,  1.33it/s]     53%|█████▎    | 9/17 [00:14<00:12,  1.52s/it]     65%|██████▍   | 11/17 [00:14<00:06,  1.08s/it]     88%|████████▊ | 15/17 [00:14<00:01,  1.72it/s]    100%|██████████| 17/17 [00:14<00:00,  1.17it/s]
      0%|          | 0/51 [00:00<?, ?it/s]     76%|███████▋  | 39/51 [00:00<00:00, 378.63it/s]    100%|██████████| 51/51 [00:00<00:00, 420.19it/s]




.. GENERATED FROM PYTHON SOURCE LINES 28-34

Clustering the Vectors
======================
It is very important that we first normalize the real and reciprocal space distances
The column scale factors map the real space and reciprocal space distances to the same scale
Here this means that the clustering algorithm operates on 4 nm in real space and .1 nm^-1 in
reciprocal space based on the units for the vectors.

.. GENERATED FROM PYTHON SOURCE LINES 34-45

.. code-block:: Python

    clustered = flat_vectors.cluster(
        scan,
        column_scale_factors=[2, 2, 0.05, 0.05],
        columns=[0, 1, 2, 3],
        min_vectors=40,
    )
    m, p = clustered.to_markers(s, alpha=0.8, get_polygons=True)
    s.plot()
    s.add_marker(m)
    s.add_marker(p, plot_on_signal=False)




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /examples/vectors/images/sphx_glr_clustering_vectors_001.png
         :alt: clustering vectors
         :srcset: /examples/vectors/images/sphx_glr_clustering_vectors_001.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples/vectors/images/sphx_glr_clustering_vectors_002.png
         :alt:  Signal
         :srcset: /examples/vectors/images/sphx_glr_clustering_vectors_002.png
         :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          | 0/2 [00:00<?, ?it/s]     50%|█████     | 1/2 [00:00<00:00,  1.29it/s]    100%|██████████| 2/2 [00:00<00:00,  2.58it/s]




.. GENERATED FROM PYTHON SOURCE LINES 46-57

.. code-block:: Python


    vect = clustered.map_vectors(
        pxm.utils.vectors.column_mean,
        columns=[0, 1],
        label_index=-1,
        dtype=float,
        shape=(2,),
    )
    plt.figure()
    plt.scatter(vect[:, 1], vect[:, 0])




.. image-sg:: /examples/vectors/images/sphx_glr_clustering_vectors_003.png
   :alt: clustering vectors
   :srcset: /examples/vectors/images/sphx_glr_clustering_vectors_003.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/numpy/_core/fromnumeric.py:3860: RuntimeWarning: Mean of empty slice.
      return _methods._mean(a, axis=axis, dtype=dtype,
    /opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/numpy/_core/_methods.py:136: RuntimeWarning: invalid value encountered in divide
      ret = um.true_divide(

    <matplotlib.collections.PathCollection object at 0x7f2c931cedb0>



.. GENERATED FROM PYTHON SOURCE LINES 58-64

.. code-block:: Python


    clusterer = DBSCAN(min_samples=2, eps=4)

    clustered2 = clustered.cluster_labeled_vectors(method=clusterer)
    m, p = clustered2.to_markers(s, alpha=0.8, get_polygons=True)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    34 : Clusters Found!




.. GENERATED FROM PYTHON SOURCE LINES 65-70

Visualizing the Clustering
==========================

This clustering is works pretty good after the second step.  We can interact with the results as well in order
to see regions where the clustering doesn't work quite as well!

.. GENERATED FROM PYTHON SOURCE LINES 72-81

.. code-block:: Python


    m, p = clustered2.to_markers(
        s, alpha=0.8, get_polygons=True, facecolor="none", sizes=(30,), lw=5
    )
    s.axes_manager.indices = (45, 45)
    s.plot()
    s.add_marker(m)
    s.add_marker(p, plot_on_signal=False)
    # sphinx_gallery_thumbnail_number = 5



.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /examples/vectors/images/sphx_glr_clustering_vectors_004.png
         :alt: clustering vectors
         :srcset: /examples/vectors/images/sphx_glr_clustering_vectors_004.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples/vectors/images/sphx_glr_clustering_vectors_005.png
         :alt:  Signal
         :srcset: /examples/vectors/images/sphx_glr_clustering_vectors_005.png
         :class: sphx-glr-multi-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 52.476 seconds)


.. _sphx_glr_download_examples_vectors_clustering_vectors.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: clustering_vectors.ipynb <clustering_vectors.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: clustering_vectors.py <clustering_vectors.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: clustering_vectors.zip <clustering_vectors.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
