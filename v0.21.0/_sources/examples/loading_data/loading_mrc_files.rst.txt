
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/loading_data/loading_mrc_files.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_loading_data_loading_mrc_files.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_loading_data_loading_mrc_files.py:


Loading MRC files (and other binary files)
==========================================

This is a simple example of how to load MRC files using Pyxem. The MRC file format is
a common format for electron microscopy data.  It is a binary format that is used
for storing 3D data, such as electron tomography but because it is a fairly simple format, it has
been adopted in some cases to store 4D STEM data as well.

First we will download a sample MRC file from the Pyxem data repository. This is a good way to host
data if you want to share it with others.  I love putting small versions (up to 50 GB) of every dataset I publish
on Zenodo and then using pooch to automate the download/extraction process.

.. GENERATED FROM PYTHON SOURCE LINES 14-31

.. code-block:: Python


    import os
    import zipfile
    import pooch

    current_directory = os.getcwd()
    file_path = pooch.retrieve(
        # URL to one of Pooch's test files
        url="https://zenodo.org/records/15490547/files/ZrNbMrc.zip",
        known_hash="md5:eeac29aee5622972daa86a394a8c1d5c",
        progressbar=True,
        path=current_directory,
    )
    # Unzip the file
    with zipfile.ZipFile(file_path, "r") as zip_ref:
        zip_ref.extractall(current_directory)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|                                              | 0.00/35.5M [00:00<?, ?B/s]      0%|                                     | 11.3k/35.5M [00:00<07:20, 80.7kB/s]      0%|                                      | 39.9k/35.5M [00:00<04:17, 138kB/s]      0%|                                      | 95.2k/35.5M [00:00<02:28, 239kB/s]      1%|▏                                      | 203k/35.5M [00:00<01:21, 435kB/s]      1%|▍                                      | 430k/35.5M [00:00<00:42, 818kB/s]      2%|▉                                     | 871k/35.5M [00:00<00:22, 1.53MB/s]      5%|█▊                                   | 1.77M/35.5M [00:01<00:11, 2.95MB/s]     10%|███▋                                 | 3.55M/35.5M [00:01<00:05, 5.72MB/s]     20%|███████▎                             | 7.04M/35.5M [00:01<00:02, 11.0MB/s]     27%|█████████▉                           | 9.52M/35.5M [00:01<00:02, 12.6MB/s]     35%|█████████████                        | 12.5M/35.5M [00:01<00:01, 14.8MB/s]     44%|████████████████▎                    | 15.7M/35.5M [00:01<00:01, 16.5MB/s]     54%|███████████████████▊                 | 19.0M/35.5M [00:01<00:00, 18.1MB/s]     63%|███████████████████████▎             | 22.4M/35.5M [00:02<00:00, 19.3MB/s]     73%|███████████████████████████▏         | 26.1M/35.5M [00:02<00:00, 20.7MB/s]     83%|██████████████████████████████▋      | 29.4M/35.5M [00:02<00:00, 20.9MB/s]     93%|██████████████████████████████████▎  | 33.0M/35.5M [00:02<00:00, 21.6MB/s]      0%|                                              | 0.00/35.5M [00:00<?, ?B/s]    100%|██████████████████████████████████████| 35.5M/35.5M [00:00<00:00, 227GB/s]




.. GENERATED FROM PYTHON SOURCE LINES 32-38

Loading the MRC file
--------------------
We can now load the file using the ``load`` method from hyperspy.  This method uses
the `MRC Reader <https://hyperspy.org/rosettasciio/supported_formats/mrc.html#mrc-format>`_
to read the file. In this case, because the file was collected with a Direct Electron camera,
the metadata is automatically loaded as well.

.. GENERATED FROM PYTHON SOURCE LINES 38-44

.. code-block:: Python


    import hyperspy.api as hs

    signal = hs.load(
        "ZrNbMrc/20241021_00405_movie.mrc",
    )







.. GENERATED FROM PYTHON SOURCE LINES 45-51

Loading Lazily
--------------
In this case the file was loaded using the numpy.memmap function,
this won't load the entire file into memory, but if for example you
do ``signal.sum()`` now the entire file will be loaded into memory.
In most cases it is better to just use the ``lazy=True`` option to load the file lazily.

.. GENERATED FROM PYTHON SOURCE LINES 51-55

.. code-block:: Python


    signal = hs.load("ZrNbMrc/20241021_00405_movie.mrc", lazy=True)

    signal





.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <table>
        <tr>
            <td>
                <table>
                    <thead>
                        <tr>
                            <th> Title: </th>
                            <td>  </td>
                        </tr>
                        <tr>
                            <th> SignalType: </th>
                            <td>  </td>
                        </tr>
                    </thead>
                    <thead>
                        <tr>
                            <td>  </td>
                            <th> Array </th>
                            <th> Chunk </th>
                        </tr>
                    </thead>
                    <tbody>
                    
                        <tr>
                            <th> Bytes </th>
                            <td> 37.50 MiB </td>
                            <td> 37.50 MiB </td>
                        </tr>
                    
                        <tr>
                            <th> Shape </th>
                            <td> (30, 20|128, 128) </td>
                            <td> (<b>30</b>,<b>20</b>|<b>128</b>,<b>128</b>) </td>
                        </tr>
                        <tr>
                            <th> Count </th>
                            <td> 2 Tasks </td>
                            <td> 1 Chunks </td>
                        </tr>
                        <tr>
                        <th> Type </th>
                        <td> float32 </td>
                        <td> numpy.ndarray </td>
                        </tr>
                    </tbody>
                </table>
            </td>
            <td>
                <table>
                    <thead>
                        <tr>
                            <th><p style="text-align:left;">Navigation Axes</p>  </th>
                            <th> <p style="text-align:left;">Signal Axes</p> </th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td> <svg width="170" height="130" style="stroke:rgb(0,0,0);stroke-width:1" >

      <!-- Horizontal lines -->
      <line x1="0" y1="0" x2="120" y2="0" style="stroke-width:2" />
      <line x1="0" y1="80" x2="120" y2="80" style="stroke-width:2" />

      <!-- Vertical lines -->
      <line x1="0" y1="0" x2="0" y2="80" style="stroke-width:2" />
      <line x1="120" y1="0" x2="120" y2="80" style="stroke-width:2" />

      <!-- Colored Rectangle -->
      <polygon points="0.0,0.0 120.0,0.0 120.0,80.0 0.0,80.0" style="fill:#ECB172A0;stroke-width:0"/>

      <!-- Text -->
      <text x="60.000000" y="100.000000" font-size="1.0rem" font-weight="100" text-anchor="middle" >30</text>
      <text x="140.000000" y="40.000000" font-size="1.0rem" font-weight="100" text-anchor="middle" transform="rotate(0,140.000000,40.000000)">20</text>
    </svg> </td>
                            <td> <svg width="170" height="170" style="stroke:rgb(0,0,0);stroke-width:1" >

      <!-- Horizontal lines -->
      <line x1="0" y1="0" x2="120" y2="0" style="stroke-width:2" />
      <line x1="0" y1="120" x2="120" y2="120" style="stroke-width:2" />

      <!-- Vertical lines -->
      <line x1="0" y1="0" x2="0" y2="120" style="stroke-width:2" />
      <line x1="120" y1="0" x2="120" y2="120" style="stroke-width:2" />

      <!-- Colored Rectangle -->
      <polygon points="0.0,0.0 120.0,0.0 120.0,120.0 0.0,120.0" style="fill:#ECB172A0;stroke-width:0"/>

      <!-- Text -->
      <text x="60.000000" y="140.000000" font-size="1.0rem" font-weight="100" text-anchor="middle" >128</text>
      <text x="140.000000" y="60.000000" font-size="1.0rem" font-weight="100" text-anchor="middle" transform="rotate(-90,140.000000,60.000000)">128</text>
    </svg> </td>
                        </tr>
                    </tbody>
                </table>
            </td>
        </tr>
    </table>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 56-64

Controlling the Chunk Size
--------------------------
The chunk size is the number of frames that will be loaded into memory at once when
the signal is lazy loaded.  This can be controlled using the ``chunks`` parameter.
A good place to start is to use the ``auto`` option for the first two dimensions, which will
automatically determine the chunk size based on the available memory. The last two dimensions
are the reciprocal space dimensions, as we usually ``map`` over those dimensions we can set them
to ``-1`` to indicate that we want to load all the data in those dimensions at once.

.. GENERATED FROM PYTHON SOURCE LINES 64-68

.. code-block:: Python


    signal = hs.load("ZrNbMrc/20241021_00405_movie.mrc", lazy=True, chunks=(10, 10, -1, -1))

    signal





.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <table>
        <tr>
            <td>
                <table>
                    <thead>
                        <tr>
                            <th> Title: </th>
                            <td>  </td>
                        </tr>
                        <tr>
                            <th> SignalType: </th>
                            <td>  </td>
                        </tr>
                    </thead>
                    <thead>
                        <tr>
                            <td>  </td>
                            <th> Array </th>
                            <th> Chunk </th>
                        </tr>
                    </thead>
                    <tbody>
                    
                        <tr>
                            <th> Bytes </th>
                            <td> 37.50 MiB </td>
                            <td> 6.25 MiB </td>
                        </tr>
                    
                        <tr>
                            <th> Shape </th>
                            <td> (30, 20|128, 128) </td>
                            <td> (10,10|<b>128</b>,<b>128</b>) </td>
                        </tr>
                        <tr>
                            <th> Count </th>
                            <td> 12 Tasks </td>
                            <td> 6 Chunks </td>
                        </tr>
                        <tr>
                        <th> Type </th>
                        <td> float32 </td>
                        <td> numpy.ndarray </td>
                        </tr>
                    </tbody>
                </table>
            </td>
            <td>
                <table>
                    <thead>
                        <tr>
                            <th><p style="text-align:left;">Navigation Axes</p>  </th>
                            <th> <p style="text-align:left;">Signal Axes</p> </th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td> <svg width="170" height="130" style="stroke:rgb(0,0,0);stroke-width:1" >

      <!-- Horizontal lines -->
      <line x1="0" y1="0" x2="120" y2="0" style="stroke-width:2" />
      <line x1="0" y1="40" x2="120" y2="40" />
      <line x1="0" y1="80" x2="120" y2="80" style="stroke-width:2" />

      <!-- Vertical lines -->
      <line x1="0" y1="0" x2="0" y2="80" style="stroke-width:2" />
      <line x1="40" y1="0" x2="40" y2="80" />
      <line x1="80" y1="0" x2="80" y2="80" />
      <line x1="120" y1="0" x2="120" y2="80" style="stroke-width:2" />

      <!-- Colored Rectangle -->
      <polygon points="0.0,0.0 120.0,0.0 120.0,80.0 0.0,80.0" style="fill:#ECB172A0;stroke-width:0"/>

      <!-- Text -->
      <text x="60.000000" y="100.000000" font-size="1.0rem" font-weight="100" text-anchor="middle" >30</text>
      <text x="140.000000" y="40.000000" font-size="1.0rem" font-weight="100" text-anchor="middle" transform="rotate(0,140.000000,40.000000)">20</text>
    </svg> </td>
                            <td> <svg width="170" height="170" style="stroke:rgb(0,0,0);stroke-width:1" >

      <!-- Horizontal lines -->
      <line x1="0" y1="0" x2="120" y2="0" style="stroke-width:2" />
      <line x1="0" y1="120" x2="120" y2="120" style="stroke-width:2" />

      <!-- Vertical lines -->
      <line x1="0" y1="0" x2="0" y2="120" style="stroke-width:2" />
      <line x1="120" y1="0" x2="120" y2="120" style="stroke-width:2" />

      <!-- Colored Rectangle -->
      <polygon points="0.0,0.0 120.0,0.0 120.0,120.0 0.0,120.0" style="fill:#ECB172A0;stroke-width:0"/>

      <!-- Text -->
      <text x="60.000000" y="140.000000" font-size="1.0rem" font-weight="100" text-anchor="middle" >128</text>
      <text x="140.000000" y="60.000000" font-size="1.0rem" font-weight="100" text-anchor="middle" transform="rotate(-90,140.000000,60.000000)">128</text>
    </svg> </td>
                        </tr>
                    </tbody>
                </table>
            </td>
        </tr>
    </table>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 69-76

Slicing the Signal
------------------
Interestingly, binary files are sometimes faster than compressed formats.  With compressed file formats,
like HDF5 or Zarr, you need to decompress the entire chunk before you can access and part of the
data. For things like Virtual Images or slicing a signal this can add overhead.  With binary files,
because the underlying data is a memory map, even for dask arrays, you can very efficiently slice parts
of the data without loading the entire chunk into memory.

.. GENERATED FROM PYTHON SOURCE LINES 76-80

.. code-block:: Python


    slice_sum = signal.isig[0:10, 0:10].sum()
    slice_sum.compute()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          | 0/16 [00:00<?, ?it/s]    100%|██████████| 16/16 [00:00<00:00, 2099.38it/s]




.. GENERATED FROM PYTHON SOURCE LINES 81-89

In this case this is faster than the compressed equivalent, because we don't have to load the
entire chunk into memory just to throw most of it away.

A couple of more things to note.  Performance of binary files is usually better on SSDs than on HDDs,
because the seek time is much lower on SSDs.  This means that you can have arbitrary dask chunks and it will
still be fast. On HDDs, you want to keep data that is close together in the same chunk. Usually this means
you want chunks like (1, "auto", -1, -1).  This is not terribly noticeable for 1-2 GB files, somewhat noticeable
for 10-20 GB files, and extremely important for 100+ GB files on an HDD.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 3.667 seconds)


.. _sphx_glr_download_examples_loading_data_loading_mrc_files.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: loading_mrc_files.ipynb <loading_mrc_files.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: loading_mrc_files.py <loading_mrc_files.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: loading_mrc_files.zip <loading_mrc_files.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
